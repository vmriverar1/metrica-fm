exports.id=1220,exports.ids=[1220],exports.modules={31075:(t,e,i)=>{"use strict";i.d(e,{Fz:()=>u,vF:()=>h});var s=i(79748),a=i.n(s),r=i(33873),n=i.n(r),o=i(94735);let l={trace:0,debug:1,info:2,warn:3,error:4,fatal:5},c={logLevel:"info",logDir:"data/logs",maxFileSize:0xa00000,maxFiles:10,enableAudit:!0,enablePerformance:!0,enableSecurity:!0,rotateDaily:!0,compressOldLogs:!1};class u extends o.EventEmitter{constructor(t={}){super(),this.currentLogFile="",this.auditLogFile="",this.performanceLogFile="",this.securityLogFile="",this.writeQueue=Promise.resolve(),this.stats={totalEntries:0,entriesByLevel:{trace:0,debug:0,info:0,warn:0,error:0,fatal:0},entriesByCategory:{},oldestEntry:"",newestEntry:"",currentFileSize:0,totalFiles:0},this.config={...c,...t},this.initializeLogger()}async initializeLogger(){try{await a().mkdir(this.config.logDir,{recursive:!0});let t=new Date().toISOString().split("T")[0];this.currentLogFile=n().join(this.config.logDir,`app-${t}.log`),this.auditLogFile=n().join(this.config.logDir,`audit-${t}.log`),this.performanceLogFile=n().join(this.config.logDir,`performance-${t}.log`),this.securityLogFile=n().join(this.config.logDir,`security-${t}.log`),await this.calculateStats(),this.emit("initialized")}catch(t){throw console.error("Failed to initialize logger:",t),t}}async writeLog(t,e,i,s,a){if(l[t]<l[this.config.logLevel])return;let r={timestamp:new Date().toISOString(),level:t,category:e,message:i,metadata:s,...a};return this.writeQueue=this.writeQueue.then(async()=>{await this.writeLogEntry(r,this.currentLogFile),this.updateStats(r),this.emit("log",r)}),this.writeQueue}async writeLogEntry(t,e){try{await this.checkFileRotation(e);let i=JSON.stringify(t)+"\n";await a().appendFile(e,i,"utf-8"),this.stats.currentFileSize+=i.length}catch(t){console.error("Failed to write log entry:",t),this.emit("error",t)}}async checkFileRotation(t){try{(await a().stat(t)).size>=this.config.maxFileSize&&await this.rotateLogFile(t)}catch(t){}}async rotateLogFile(t){let e=new Date().toISOString().replace(/[:.]/g,"-"),i=t.replace(".log",`-${e}.log`);try{await a().rename(t,i),this.stats.totalFiles++,this.stats.currentFileSize=0,this.config.compressOldLogs,await this.cleanupOldLogs(),this.emit("rotated",{original:t,rotated:i})}catch(t){console.error("Failed to rotate log file:",t)}}async cleanupOldLogs(){try{let t=(await a().readdir(this.config.logDir)).filter(t=>t.endsWith(".log")).map(t=>({name:t,path:n().join(this.config.logDir,t),stat:null}));for(let e of t)try{e.stat=await a().stat(e.path)}catch{}for(let e of t.filter(t=>t.stat).sort((t,e)=>e.stat.mtime.getTime()-t.stat.mtime.getTime()).slice(this.config.maxFiles))try{await a().unlink(e.path),this.stats.totalFiles--,this.emit("cleanup",e.path)}catch(t){console.error(`Failed to delete old log file ${e.path}:`,t)}}catch(t){console.error("Failed to cleanup old logs:",t)}}updateStats(t){this.stats.totalEntries++,this.stats.entriesByLevel[t.level]++,this.stats.entriesByCategory[t.category]||(this.stats.entriesByCategory[t.category]=0),this.stats.entriesByCategory[t.category]++,(!this.stats.oldestEntry||t.timestamp<this.stats.oldestEntry)&&(this.stats.oldestEntry=t.timestamp),(!this.stats.newestEntry||t.timestamp>this.stats.newestEntry)&&(this.stats.newestEntry=t.timestamp)}async calculateStats(){try{let t=await a().readdir(this.config.logDir);if(this.stats.totalFiles=t.filter(t=>t.endsWith(".log")).length,this.currentLogFile)try{let t=await a().stat(this.currentLogFile);this.stats.currentFileSize=t.size}catch{this.stats.currentFileSize=0}}catch{}}trace(t,e,i,s){return this.writeLog("trace",t,e,i,s)}debug(t,e,i,s){return this.writeLog("debug",t,e,i,s)}info(t,e,i,s){return this.writeLog("info",t,e,i,s)}warn(t,e,i,s){return this.writeLog("warn",t,e,i,s)}error(t,e,i,s,a){let r=i?{error:{name:i.name,message:i.message,stack:i.stack},...s}:s;return this.writeLog("error",t,e,r,a)}fatal(t,e,i,s,a){let r=i?{error:{name:i.name,message:i.message,stack:i.stack},...s}:s;return this.writeLog("fatal",t,e,r,a)}async audit(t){if(!this.config.enableAudit)return;let e={timestamp:new Date().toISOString(),level:"info",category:"audit",...t};return this.writeQueue=this.writeQueue.then(async()=>{await this.writeLogEntry(e,this.auditLogFile),this.emit("audit",e)}),this.writeQueue}async performance(t){if(!this.config.enablePerformance)return;let e={timestamp:t.timestamp,level:"info",category:"performance",message:`${t.operation} completed in ${t.duration}ms`,metadata:{operation:t.operation,duration:t.duration,success:t.success,...t.metadata}};return this.writeQueue=this.writeQueue.then(async()=>{await this.writeLogEntry(e,this.performanceLogFile),this.emit("performance",e)}),this.writeQueue}async security(t,e,i,s){if(!this.config.enableSecurity)return;let a={timestamp:new Date().toISOString(),level:"failure"===e?"warn":"info",category:"security",message:`Security event: ${t} - ${e}`,metadata:{action:t,result:e,...i},...s};return this.writeQueue=this.writeQueue.then(async()=>{await this.writeLogEntry(a,this.securityLogFile),this.emit("security",a)}),this.writeQueue}getStats(){return{...this.stats}}async searchLogs(t){return[]}async exportLogs(t,e){return JSON.stringify({message:"Export functionality not implemented yet"})}async cleanupLogsByDate(t){let e=0;try{let i=await a().readdir(this.config.logDir),s=new Date(t);for(let t of i){if(!t.endsWith(".log"))continue;let i=n().join(this.config.logDir,t);(await a().stat(i)).mtime<s&&(await a().unlink(i),e++)}await this.calculateStats(),this.emit("cleanup",{cleaned:e,olderThan:t})}catch(t){console.error("Failed to cleanup logs by date:",t)}return e}async destroy(){await this.writeQueue,this.emit("destroyed"),this.removeAllListeners()}}let h=new u},47687:(t,e,i)=>{"use strict";i.d(e,{OT:()=>g,a5:()=>h});var s=i(79748),a=i.n(s),r=i(33873),n=i.n(r),o=i(55511),l=i.n(o);class c extends Error{constructor(t,e,i){super(t),this.expectedEtag=e,this.actualEtag=i,this.name="FileConflictError"}}class u extends Error{constructor(t,e){super(t),this.lockFile=e,this.name="FileLockError"}}class h{constructor(t="public/json",e="data/locks"){this.baseDir=t,this.lockDir=e,this.locks=new Map,this.lockTimeout=3e4,this.backupDir=n().join("data","backups"),this.ensureDirectories()}async ensureDirectories(){for(let t of[this.baseDir,this.lockDir,this.backupDir])try{await a().access(t)}catch{await a().mkdir(t,{recursive:!0})}}generateEtag(t){return l().createHash("md5").update(t).digest("hex")}getFilePath(t){return n().join(this.baseDir,t)}getLockPath(t){let e=t.replace(/[^a-zA-Z0-9]/g,"_");return n().join(this.lockDir,`${e}.lock`)}getBackupPath(t){let e=new Date().toISOString().replace(/[:.]/g,"-"),i=n().basename(t,".json");return n().join(this.backupDir,`${i}_${e}.json`)}async getFileMetadata(t){let e=this.getFilePath(t);try{let i=await a().stat(e),s=await a().readFile(e,"utf-8"),r=this.generateEtag(s);return{path:t,size:i.size,etag:r,lastModified:i.mtime,version:"1.0.0"}}catch(e){throw Error(`Failed to get metadata for ${t}: ${e.message}`)}}async acquireLock(t,e=this.lockTimeout){let i=this.getLockPath(t),s=n().resolve(t);this.locks.has(s)&&await this.locks.get(s);let a=this.createLock(i,e);this.locks.set(s,a);try{let t=await a;return async()=>{await t(),this.locks.delete(s)}}catch(t){throw this.locks.delete(s),t}}async createLock(t,e){let i=JSON.stringify({pid:process.pid,timestamp:new Date().toISOString(),timeout:e}),s=Date.now();for(;Date.now()-s<e;)try{return await a().writeFile(t,i,{flag:"wx"}),async()=>{try{await a().unlink(t)}catch(e){console.warn(`Warning: Could not remove lock file ${t}:`,e.message)}}}catch(e){if("EEXIST"===e.code){try{let e=JSON.parse(await a().readFile(t,"utf-8"));if(Date.now()-new Date(e.timestamp).getTime()>(e.timeout||this.lockTimeout)){await a().unlink(t);continue}}catch{try{await a().unlink(t);continue}catch{}}await this.sleep(100)}else throw new u(`Failed to acquire lock: ${e.message}`,t)}throw new u(`Lock acquisition timeout after ${e}ms`,t)}sleep(t){return new Promise(e=>setTimeout(e,t))}async readJSON(t,e={}){let i=this.getFilePath(t);try{let[s,r]=await Promise.all([a().readFile(i,"utf-8"),e.includeMetadata?this.getFileMetadata(t):null]);return{data:JSON.parse(s),metadata:r||{path:t,size:s.length,etag:this.generateEtag(s),lastModified:new Date,version:"1.0.0"}}}catch(e){throw Error(`Failed to read JSON file ${t}: ${e.message}`)}}async writeJSON(t,e,i={}){let s,r=this.getFilePath(t),o=`${r}.tmp`,l=null;try{if(i.ensureDirectory&&await a().mkdir(n().dirname(r),{recursive:!0}),l=await this.acquireLock(r,i.timeout),i.validateEtag)try{let t=await a().readFile(r,"utf-8"),e=this.generateEtag(t);if(e!==i.validateEtag)throw new c("File has been modified by another process",i.validateEtag,e)}catch(t){if(t instanceof c)throw t}if(i.createBackup)try{s=this.getBackupPath(r),await a().copyFile(r,s)}catch(t){}let u=JSON.stringify(e,null,2);this.generateEtag(u),await a().writeFile(o,u,"utf-8"),await a().rename(o,r);let h=await this.getFileMetadata(t);return{success:!0,metadata:h,backupPath:s}}catch(t){try{await a().unlink(o)}catch{}throw t}finally{l&&await l()}}async exists(t){try{return await a().access(this.getFilePath(t)),!0}catch{return!1}}async deleteJSON(t,e=!0){let i=this.getFilePath(t),s=null;try{if(!await this.exists(t))return!1;if(s=await this.acquireLock(i),e){let t=this.getBackupPath(i);await a().copyFile(i,t)}return await a().unlink(i),!0}catch(e){throw Error(`Failed to delete file ${t}: ${e.message}`)}finally{s&&await s()}}async listFiles(t=""){let e=n().join(this.baseDir,t);try{let i=await a().readdir(e,{withFileTypes:!0}),s=[];for(let e of i)if(e.isFile()&&e.name.endsWith(".json"))s.push(n().join(t,e.name));else if(e.isDirectory()){let i=await this.listFiles(n().join(t,e.name));s.push(...i)}return s.sort()}catch(e){throw Error(`Failed to list files in ${t}: ${e.message}`)}}async cleanupExpiredLocks(){try{let t=await a().readdir(this.lockDir),e=0;for(let i of t){if(!i.endsWith(".lock"))continue;let t=n().join(this.lockDir,i);try{let i=JSON.parse(await a().readFile(t,"utf-8")),s=Date.now()-new Date(i.timestamp).getTime(),r=i.timeout||this.lockTimeout;s>r&&(await a().unlink(t),e++)}catch(i){try{await a().unlink(t),e++}catch{}}}return e}catch(t){return console.warn("Warning: Could not cleanup expired locks:",t.message),0}}}let g=new h},78335:()=>{},92e3:(t,e,i)=>{"use strict";i.d(e,{s:()=>h});var s=i(55511),a=i.n(s),r=i(43205),n=i.n(r),o=i(47687),l=i(31075);let c={magicLinkTTL:15,sessionTTL:24,maxLoginAttempts:5,lockoutDuration:30,rateLimitWindow:15,rateLimitMax:10,enableEmailNotifications:!1};class u{constructor(t){if(this.users=[],this.activeSessions=new Map,this.magicTokens=new Map,this.loginAttempts=new Map,this.usersFile="data/users.json",this.sessionsFile="data/sessions.json",this.attemptsFile="data/login-attempts.json",!t.jwtSecret)throw Error("JWT secret is required for AuthManager");this.config={...c,...t},this.initializeAuth()}async initializeAuth(){try{await this.loadUsers(),await this.loadActiveSessions(),await this.loadLoginAttempts(),this.startCleanupTimer(),await l.vF.info("auth","AuthManager initialized successfully",{usersCount:this.users.length,activeSessionsCount:this.activeSessions.size})}catch(t){throw await l.vF.error("auth","Failed to initialize AuthManager",t),t}}async loadUsers(){try{if(await o.OT.exists(this.usersFile)){let t=await o.OT.readJSON(this.usersFile);this.users=t.data.users||[]}else await this.createDefaultAdmin()}catch(t){await l.vF.warn("auth","Could not load users, using empty list",{error:t.message}),this.users=[]}}async createDefaultAdmin(){let t={id:"admin_"+a().randomBytes(8).toString("hex"),email:process.env.DEFAULT_ADMIN_EMAIL||"admin@metrica-dip.com",name:"Administrador",role:"admin",status:"active",created_at:new Date().toISOString(),login_attempts:0};this.users=[t],await this.saveUsers(),await l.vF.info("auth","Created default admin user",{email:t.email,id:t.id})}async saveUsers(){await o.OT.writeJSON(this.usersFile,{users:this.users},{createBackup:!0,ensureDirectory:!0})}async loadActiveSessions(){try{if(await o.OT.exists(this.sessionsFile)){let t=(await o.OT.readJSON(this.sessionsFile)).data.sessions||[],e=new Date;t.forEach(t=>{new Date(t.expires_at)>e&&this.activeSessions.set(t.sessionId,t)})}}catch(t){await l.vF.warn("auth","Could not load sessions",{error:t.message})}}async saveSessions(){let t=Array.from(this.activeSessions.values());await o.OT.writeJSON(this.sessionsFile,{sessions:t},{ensureDirectory:!0})}async loadLoginAttempts(){try{if(await o.OT.exists(this.attemptsFile)){let t=(await o.OT.readJSON(this.attemptsFile)).data.attempts||{},e=new Date(Date.now()-60*this.config.rateLimitWindow*1e3);Object.entries(t).forEach(([t,i])=>{let s=i.filter(t=>new Date(t.timestamp)>e);s.length>0&&this.loginAttempts.set(t,s)})}}catch(t){await l.vF.warn("auth","Could not load login attempts",{error:t.message})}}async saveLoginAttempts(){let t={};this.loginAttempts.forEach((e,i)=>{t[i]=e}),await o.OT.writeJSON(this.attemptsFile,{attempts:t},{ensureDirectory:!0})}startCleanupTimer(){setInterval(async()=>{await this.cleanupExpiredTokens(),await this.cleanupExpiredSessions(),await this.cleanupOldLoginAttempts()},3e5)}checkRateLimit(t){let e=this.loginAttempts.get(t)||[],i=new Date(Date.now()-60*this.config.rateLimitWindow*1e3);return e.filter(t=>new Date(t.timestamp)>i).length<this.config.rateLimitMax}async recordLoginAttempt(t,e,i,s,a){let r={email:t,timestamp:new Date().toISOString(),ip_address:e,user_agent:i,success:s,reason:a},n=this.loginAttempts.get(e)||[];n.push(r);let o=new Date(Date.now()-60*this.config.rateLimitWindow*1e3),c=n.filter(t=>new Date(t.timestamp)>o);this.loginAttempts.set(e,c),.1>Math.random()&&await this.saveLoginAttempts(),await l.vF.info("auth",`Login attempt: ${s?"success":"failed"}`,{email:t,ipAddress:e,success:s,reason:a})}findUserByEmail(t){return this.users.find(e=>e.email.toLowerCase()===t.toLowerCase())||null}findUserById(t){return this.users.find(e=>e.id===t)||null}isUserLocked(t){return!!t.locked_until&&new Date(t.locked_until)>new Date}async lockUser(t){t.locked_until=new Date(Date.now()+60*this.config.lockoutDuration*1e3).toISOString(),t.login_attempts=0,await this.saveUsers(),await l.vF.warn("auth","User locked due to too many failed attempts",{userId:t.id,email:t.email,lockedUntil:t.locked_until})}generateMagicToken(t,e,i){let s=a().randomBytes(32).toString("hex"),r=new Date(Date.now()+60*this.config.magicLinkTTL*1e3),n={token:s,email:t.toLowerCase(),expires_at:r.toISOString(),used:!1,created_at:new Date().toISOString(),ip_address:e,user_agent:i};return this.magicTokens.set(s,n),s}generateJWT(t,e){let i={userId:t.id,email:t.email,role:t.role,sessionId:e,iat:Math.floor(Date.now()/1e3),exp:Math.floor(Date.now()/1e3)+3600*this.config.sessionTTL};return n().sign(i,this.config.jwtSecret)}verifyJWT(t){try{let e=n().verify(t,this.config.jwtSecret),i=e.sessionId;if(!this.activeSessions.has(i))return{valid:!1,error:"Session not found"};return{valid:!0,payload:e}}catch(t){return{valid:!1,error:t.message}}}async requestMagicLink(t,e,i){try{let s=t.toLowerCase().trim();if(!this.checkRateLimit(e))return await this.recordLoginAttempt(s,e,i,!1,"rate_limited"),{success:!1,message:"Too many requests. Please try again later.",error:"RATE_LIMITED"};let a=this.findUserByEmail(s);if(!a)return await this.recordLoginAttempt(s,e,i,!1,"user_not_found"),{success:!0,message:"If the email exists, a magic link has been sent."};if("active"!==a.status)return await this.recordLoginAttempt(s,e,i,!1,"user_inactive"),{success:!1,message:"Account is not active.",error:"USER_INACTIVE"};if(this.isUserLocked(a))return await this.recordLoginAttempt(s,e,i,!1,"user_locked"),{success:!1,message:"Account is temporarily locked. Please try again later.",error:"USER_LOCKED"};let r=this.generateMagicToken(s,e,i);return await l.vF.info("auth","Magic link generated",{email:s,token:r,ipAddress:e,development_url:`/api/admin/auth/verify?token=${r}`}),await this.recordLoginAttempt(s,e,i,!0,"magic_link_sent"),{success:!0,message:"Magic link sent to your email.",data:void 0}}catch(i){return await l.vF.error("auth","Failed to generate magic link",i,{email:t,ipAddress:e}),{success:!1,message:"Internal server error.",error:"INTERNAL_ERROR"}}}async verifyMagicLink(t,e,i){try{let s=this.magicTokens.get(t);if(!s)return await l.vF.warn("auth","Invalid magic token used",{token:t,ipAddress:e}),{success:!1,message:"Invalid or expired magic link.",error:"INVALID_TOKEN"};if(new Date(s.expires_at)<new Date)return this.magicTokens.delete(t),await l.vF.warn("auth","Expired magic token used",{token:t,ipAddress:e,expiredAt:s.expires_at}),{success:!1,message:"Magic link has expired.",error:"TOKEN_EXPIRED"};if(s.used)return await l.vF.warn("auth","Already used magic token",{token:t,ipAddress:e}),{success:!1,message:"Magic link has already been used.",error:"TOKEN_USED"};let r=this.findUserByEmail(s.email);if(!r||"active"!==r.status)return this.magicTokens.delete(t),{success:!1,message:"User account not found or inactive.",error:"USER_NOT_FOUND"};s.used=!0;let n=a().randomBytes(16).toString("hex"),o=new Date(Date.now()+3600*this.config.sessionTTL*1e3),c={userId:r.id,email:r.email,role:r.role,sessionId:n,created_at:new Date().toISOString(),expires_at:o.toISOString(),ip_address:e,user_agent:i};this.activeSessions.set(n,c);let u=this.generateJWT(r,n);return r.last_login=new Date().toISOString(),r.login_attempts=0,r.locked_until&&delete r.locked_until,await this.saveUsers(),await this.saveSessions(),this.magicTokens.delete(t),await l.vF.info("auth","User logged in successfully",{userId:r.id,email:r.email,sessionId:n,ipAddress:e}),{success:!0,message:"Login successful.",data:{token:u,user:{id:r.id,email:r.email,name:r.name,role:r.role},session:{id:n,expires_at:c.expires_at}}}}catch(i){return await l.vF.error("auth","Failed to verify magic link",i,{token:t,ipAddress:e}),{success:!1,message:"Internal server error.",error:"INTERNAL_ERROR"}}}async logout(t){try{let e=this.activeSessions.get(t);return e&&(this.activeSessions.delete(t),await this.saveSessions(),await l.vF.info("auth","User logged out",{userId:e.userId,sessionId:t})),{success:!0,message:"Logged out successfully."}}catch(e){return await l.vF.error("auth","Failed to logout",e,{sessionId:t}),{success:!1,message:"Logout failed.",error:"INTERNAL_ERROR"}}}getSession(t){let e=this.activeSessions.get(t);return e?new Date(e.expires_at)<new Date?(this.activeSessions.delete(t),null):e:null}getUserBySession(t){let e=this.getSession(t);return e?this.findUserById(e.userId):null}async cleanupExpiredTokens(){let t=new Date,e=0;for(let[i,s]of this.magicTokens.entries())(new Date(s.expires_at)<t||s.used)&&(this.magicTokens.delete(i),e++);e>0&&await l.vF.debug("auth",`Cleaned up ${e} expired magic tokens`)}async cleanupExpiredSessions(){let t=new Date,e=0;for(let[i,s]of this.activeSessions.entries())new Date(s.expires_at)<t&&(this.activeSessions.delete(i),e++);e>0&&(await this.saveSessions(),await l.vF.debug("auth",`Cleaned up ${e} expired sessions`))}async cleanupOldLoginAttempts(){let t=new Date(Date.now()-60*this.config.rateLimitWindow*1e3),e=0;for(let[i,s]of this.loginAttempts.entries()){let a=s.filter(e=>new Date(e.timestamp)>t);0===a.length?(this.loginAttempts.delete(i),e++):a.length!==s.length&&this.loginAttempts.set(i,a)}e>0&&(await this.saveLoginAttempts(),await l.vF.debug("auth",`Cleaned up login attempts for ${e} IPs`))}getAuthStats(){return{usersCount:this.users.length,activeSessionsCount:this.activeSessions.size,magicTokensCount:this.magicTokens.size,loginAttemptsCount:Array.from(this.loginAttempts.values()).reduce((t,e)=>t+e.length,0)}}getAllUsers(){return this.users.map(t=>({...t}))}}let h=new u({jwtSecret:process.env.JWT_SECRET||"default-secret-change-in-production",magicLinkTTL:15,sessionTTL:24,maxLoginAttempts:5,lockoutDuration:30,rateLimitWindow:15,rateLimitMax:10,enableEmailNotifications:!1})},96487:()=>{}};